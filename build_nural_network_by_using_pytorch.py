# -*- coding: utf-8 -*-
"""build_nural_network_by_using_PyTorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15ZuFowj4A7FmN6Bc2mig82yIcH7B90lP
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.optim import SGD

class firstNN(nn.Module):
    def __init__(self):
        super().__init__()

        self.w00 = nn.Parameter( torch.tensor(1.1) , requires_grad=False )
        self.b00 = nn.Parameter( torch.tensor(-0.5) , requires_grad=False )

        self.w01 = nn.Parameter( torch.tensor(0.6) , requires_grad=False )
        self.b01 = nn.Parameter( torch.tensor(-1.5) , requires_grad=False )

        self.w02 = nn.Parameter( torch.tensor(0.5) , requires_grad=False )
        self.b02 = nn.Parameter( torch.tensor(0.65) , requires_grad=False )

        self.w11 = nn.Parameter( torch.tensor(1.55) , requires_grad=False )
        self.w12 = nn.Parameter( torch.tensor(-0.7) , requires_grad=False )
        self.w13 = nn.Parameter( torch.tensor(1.22) , requires_grad=False )

        self.w20 = nn.Parameter( torch.tensor(1.6) , requires_grad=False )

    def forward(self,input):
        input_to_layer_01 = input * self.w00 + self.b00
        layer_01_output = F.relu(input_to_layer_01)
        layer_01_output = layer_01_output * self.w11

        input_to_layer_02 = input * self.w01 + self.b01
        layer_02_output = F.relu(input_to_layer_02)
        layer_02_output = layer_02_output * self.w12

        input_to_layer_03 = input * self.w02 + self.b02
        layer_03_output = F.relu(input_to_layer_03)
        layer_03_output = layer_03_output * self.w13

        output = layer_01_output + layer_02_output + layer_03_output

        output = F.tanh(output)
        output = output * self.w20

        return output

first_model = firstNN()

true_input = torch.linspace(start = 1 , end = 2.5 , steps = 40)
true_input

true_output =first_model(true_input)
true_output

import matplotlib.pyplot as plt
import seaborn as sns
sns.set(style = "whitegrid")
sns.lineplot(x = true_input , y = true_output , color = "red" , linewidth = 3 )
plt.ylabel ("output")
plt.xlabel ("input")

class PlainFirstNN(nn.Module):
    def __init__(self):
        super().__init__()

        self.w00 = nn.Parameter( torch.tensor(0.0) , requires_grad=True )
        self.b00 = nn.Parameter( torch.tensor(-0.5) , requires_grad=False )

        self.w01 = nn.Parameter( torch.tensor(0.6) , requires_grad=False )
        self.b01 = nn.Parameter( torch.tensor(-1.5) , requires_grad=False )

        self.w02 = nn.Parameter( torch.tensor(0.0) , requires_grad=True )
        self.b02 = nn.Parameter( torch.tensor(0.65) , requires_grad=False )

        self.w11 = nn.Parameter( torch.tensor(1.55) , requires_grad=False )
        self.w12 = nn.Parameter( torch.tensor(-0.7) , requires_grad=False )
        self.w13 = nn.Parameter( torch.tensor(1.22) , requires_grad=False )

        self.w20 = nn.Parameter( torch.tensor(1.6) , requires_grad=True )

    def forward(self,input):
        input_to_layer_01 = input * self.w00 + self.b00
        layer_01_output = F.relu(input_to_layer_01)
        layer_01_output = layer_01_output * self.w11

        input_to_layer_02 = input * self.w01 + self.b01
        layer_02_output = F.relu(input_to_layer_02)
        layer_02_output = layer_02_output * self.w12

        input_to_layer_03 = input * self.w02 + self.b02
        layer_03_output = F.relu(input_to_layer_03)
        layer_03_output = layer_03_output * self.w13

        output = layer_01_output + layer_02_output + layer_03_output

        output = F.tanh(output)
        output = output * self.w20

        return output

plain_first_model = PlainFirstNN()

pred_output = plain_first_model(true_input)
pred_output

sns.set(style="whitegrid")

sns.lineplot(
    x=true_input,
    y=pred_output.detach(),
    color='red',
    linewidth=3
)

plt.ylabel('output')
plt.xlabel('input')

optimizer = SGD(plain_first_model.parameters(), lr=0.01)
loss = nn.MSELoss()

for epoch in range(100):

    total_loss = 0

    for i in range(len(true_input)):

        input_i = true_input[i]
        true_output_i = true_output[i]

        pred_output_i = plain_first_model(input_i)

        loss_value = loss(pred_output_i, true_output_i)

        loss_value.backward()

        total_loss += loss_value

    print("Epoch:", epoch, " | Total Loss:", total_loss)

    optimizer.step()
    optimizer.zero_grad()

sns.set(style="whitegrid")

sns.lineplot(
    x=true_input,
    y=pred_output.detach(),
    color='red',
    linewidth=3
)

plt.ylabel('output')
plt.xlabel('input')

plain_first_model.w00

plain_first_model.w02

plain_first_model.w20

